以下：类型指代类或接口
# 概述
虚拟机的类加载机制：JVM把描述类的数据从Class文件加载到内存中，并对数据进行校验、解析、和初始化工作，这个过程称为类加载机制。

java语言中，类型的加载、连接、初始化过程都是在程序运行期间完成。这个策略为java应用提供了极高的可扩展性和灵活性。

# 类加载时机
类的生命周期：加载->验证->准备->解析->初始化->使用->卸载
验证、准备、解析统称为连接

《Java虚拟机规范》并没有规定什么时候进行类加载过程的第一个阶段“加载”，由虚拟机的具体实现自由把握。但是对于类的“初始化”操作，《Java虚拟机规范》严格规定了有且仅有六种情况才会立即对类进行“初始化”。在书上P263页总结了。这里列举了前四点比较常见的。
* 使用new 关键字、读取或设置静态字段（已在编译期放入常量池中的除外）、调用静态方法
* 反射调用的时候
* 初始化子类，如果父类没有初始化，需要先初始化父类。
* 包含main()方法的类

不会引发类型初始化的例子
* 通过子类引用父类的静态字段不会导致子类的初始化
* 将类型定义为数组，不会引起该类型的初始化。虚拟机会自动生成一个类，这个类直接继承自Object，因此将类型定义为数组，不会引起该类型的初始化，而是会引起这个自动生成的类的初始化。这个自动生成的类包装了对数组元素的访问，因此java中访问数组更安全，因为这个类已经替我们完成了越界检查操作。
* 使用某类型的静态常量，不会引起该类型的初始化。java在编译阶段会进行常量传播优化，因此编译阶段之后，调用的常量值会直接存储在调用类的常量池中，与被调用类型无关。这里的常量值指代static final的基本类型和String类型。调用其它static final的引用类型仍然会引起类型的初始化。
```java
public class Test {
    public static void main(String[] args) {
        System.out.println(Tests.hello);
        System.out.println(Tests.test); //加上这一行就会打印Tests init，因为引用类型除了String，其它都不会进行常量传播优化
        System.out.println(Tests.INT_MAX);
    }
}
class Tests{
    static {
        System.out.println("Tests init");
    }
    static final String hello = "hello";
    static final int INT_MAX = Integer.MAX_VALUE;
    static final Integer test = new Integer(1);
}
```
# 类加载过程
### 加载
加载过程完成三件事：
1）通过一个类的全限定名获取相应的二进制字节流
2）将二进制字节流所代表的静态结构转化成**方法区**运行时的数据结构
3）在堆中生成这个类对应的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

对于第一步，由于《Java虚拟机规范》没有规定必须从某个Class文件中获取二进制字节流，因此具有很大的操作空间。比如可以从zip压缩包（jar war ear）中读取、从网络中获取（Web Applet）、运行时计算生成（动态代理技术）、从加密文件中获取（防止Class文件被反编译）

### 验证
为了确保字节流中包含的信息符合规范，另外还需要保证这些信息被当成代码运行后，不会危害虚拟机自身的安全。
* 文件格式验证：**主要验证字节流是否符合Class文件格式规范。并且要和当前虚拟机版本对应**，从字节流的层面上进行格式检查与语法分析。具体包括是否已java魔数开头、版本号是否可被当前JVM处理、常量池的常量是否有不被支持的类型、常量池的各种索引是否有不存在或不符合类型的常量等等。
* 元数据验证：**主要对字节码描述的信息进行语义分析**，从语言的层面上进行语法分析，也就是从字节码层面上进行语义分析。包括这个类是否有父类、是否继承了final类（final类不允许被继承）、如果继承了抽象类或实现了接口，是否实现了所有方法、这个类的字段和方法是否与父类产生矛盾
* 字节码验证：**通过数据流分析和控制流分析，确定程序语义是合法且符合逻辑的**。这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会作出危害虚拟机安全的行为。如，保证方法体中的类型转换总是有效的、保证跳转指令不会跳转到方法体外等。但是可以证明，无法通过程序来判断一段程序是否存在bug，只能尽可能检测。
* 符号引用验证：**在虚拟机将符号引用转化为直接引用的时候触发校验**。包括：是否能通过全限定名找到对应的类、简单名称锁描述的方法和字段是否存在、类/字段/方法是否可被当前类访问等等。例如IllegalAccessError、NoSuchFieldError、NoSuchMethodError都是这一阶段抛出的异常。

值得注意的是：这一阶段不是必须的，可以通过-Xverify:none参数关闭大部分类验证措施，缩短虚拟机加载时间。

### 准备
这一阶段正式为**静态变量**分配内存并设置变量初始值。需要注意：
* 这一阶段只为类变量分配分配内存，不会为实例变量分配内存。
* 为变量设置初始值设置的其实是零值。那什么时候为变量设置真正的初值呢？在程序被编译后，会将为变量设初值的指令放在类构造器\<clinit\>()方法中，所以为变量设置真正的初值，是在类的初始化阶段才会执行。
* 只有类字段的字段属性表中存在ConstantValue属性时（对于这个属性的介绍在P242。可以理解成static final修饰的基本类型或String类型），才会在准备阶段就赋真正的初值。

稍微总结一下：每个类都会在堆中生成一个对应的Class对象，1.7之前类变量是存放在永久代（1.7之前Hotspot实现方法区的方式）中的，**1.7之后类对象会跟随Class对象一起放在堆中**。
之前不是说类存储在方法区中么？这是因为Hotspot虚拟机没有完全按照Java虚拟机规范实现，因此“类变量在方法区”就完全是一种对逻辑概念的表述了，与实际实现方式无关。

### 解析
**解析阶段是JVM将常量池中的符号引用替换为直接引用的过程**。符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量。直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。

* 《Java虚拟机规范》中没有规定解析阶段发生的具体时间。只要求执行用于操作符号引用的字节码指令之前先对所使用的符号引用进行解析即可。
* 对方法或字段的访问，在解析阶段找到之后会对它们的可访问性进行检查。如果不具备访问权限，会抛出NoSuchFieldError。
* 解析动作：我的理解就是根据符号引用查找直接引用，并在找到之后对访问权限进行检查。P274页给了类或接口、字段、方法、接口方法的解析过程。

### 初始化
对类的初始化操作，实际上就是执行类构造器\<clinit\>()方法的过程。这个方法是Javac编译器自动生成的。生成过程：编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句，再进行合并产生。编译器对语句的收集顺序由源文件中出现顺序决定。
* Java虚拟机保证在子类的\<clinit\>()方法执行前，父类的\<clinit\>()方法会先执行
* 如果一个类没有静态语句块也没有对类变量的赋值操作，则不会产生\<clinit\>()方法。
* 一个类的\<clinit\>()方法在多线程环境中会被正确的加锁同步。

### 卸载
卸载类就是对该类的Class对象进行GC。
卸载类需要满足 3 个要求:

* 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
* 该类没有在其他任何地方被引用
* 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。只要想通一点就好了，JDK 自带的 BootstrapClassLoader, ExtClassLoader, AppClassLoader 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

# 类加载器
### 类与类加载器
对于任何一个类，都由这个类本身和加载这个类的类加载器共同确定其在JVM中的唯一性。每一个类加载器，都有一个独立的类名称空间。也就是说，即使同一个Class文件用两个类加载器加载，那么这都算两个不同的类。

### 双亲委派机制
* 启动类加载器：负责加载存放在\<JAVA_HOME\>\lib目录下的类。HotSpot虚拟机的启动类加载器由C++实现。这个类加载器是虚拟机的一部分，区别于其它所有类型的类加载器
* 扩展类加载器：负责加载\<JAVA_HOME\>\lib\ext目录下的所有类。这是一种对系统类库的扩展机制，P283说这种扩展机制被模块化带来的天然扩展能力所取代。
* 应用程序类加载器：负责加载用户类路径（ClassPath）上所有的类库。

双亲委派模型要求除了顶层的启动类加载器之外，其它所有类加载器都需要拥有自己的上层类加载器。在类加载器加载一个类时，首先委托自己的上层类加载器加载这个类，一步步向上级委托，只有当父类加载器无法实现类加载时，才会由自己完成类加载动作。双亲委派机制保证了，无论哪一个类加载器要加载java.lang包下的类，最终都会委托给启动类加载器完成加载，这样就确保了类的唯一性。

<mark>后面的java模块化系统没有看到，对模块化系统还没有了解，之后再看</mark>

