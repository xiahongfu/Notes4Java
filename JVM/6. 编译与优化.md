前端编译器：把*.java文件编译成*.class文件
即时编译（JIT）器：在运行期间把字节码转变成本地机器码
提前编译（AOT）器：直接把源程序编译成目标机器支持的二进制代码。
[TOC]
# 前端编译与优化
类似于Javac这样的前端编译器基本没有任何优化二字可言，JVM设计团队选择把对性能的优化全部集中在即时编译器中，这样可以让不是Javac产生的Class文件也同样能享受编译器优化带来的性能提升。

Javac的前端编译过程：
1）准备过程：初始化插入式注解器
2）解析与填充符号表过程：进行词法、语法分析，并填充符号表
3）插入式注解处理器的注解处理过程
4）分析与字节码生成过程：包括注解检查、数据流及控制流分析、解语法糖、字节码生成

### java语法糖
语法糖可以方便程序员编写代码，而解语法糖的过程发生在前端编译中，因此被作者归为前端优化的一部分。

**泛型**
java中的泛型通过类型擦除来实现，因此经过Javac编译后会将泛型类型直接进行擦除（比如ArrayList\<Integer\>类型会还原成ArrayList），然后在元素访问、修改时自动插入一些强制类型转换和检查指令。
由于基本数据类型和Object类型无法进行强制转换，因此使用类型擦除导致的另一个问题就是，类似ArrayList\<int\>这样的使用方法是错误的，只能使用基本数据类型对应的包装类型。由于经常要执行强制类型转换以及自动拆装箱，这就导致java的泛型的性能很差。
另外，由于ArrayList\<Integer\>和ArrayList\<String\>在类型擦除后的都是ArrayList类，因此无法通过泛型的不同进行方法的重载（方法重载需要保证特征签名不同）。

**自动拆装箱**
实际上就是在编译之后，将自动装箱与自动拆箱转化成对应的包装和还原方法。比如
```java
Integer a = 1;
int b = a;
```
在自动拆装箱之后会变成
```java
Integer a = Integer.valueOf(1);
int b = a.intValue();
```
自动拆装箱在判等时的坑（具体见P376）：
①：包装类用\=\=判等，除非遇到算术运算否则不会进行自动拆装箱。
②：包装类的equals方法不能处理数据转型
③：为了节省内存，Integer.valueOf()对于较小的数（-128到127），始终返回相同的实例。这一块可以看看源码。

**条件编译**
当if语句的条件为常量时，会进行条件优化。比如下面这段代码
```java
if(true) {
    System.out.println("this is true block");
} else {
    System.out.println("this is false block");
}
```
在经过条件编译优化后，会变成下面这样。
```java
System.out.println("this is true block");
```
但是只有使用条件为常量（逻辑上是常量也不行）的if语句才可以。

**其它语法糖包括遍历循环、方法的变长参数、内部类、枚举类、断言等以后有时间可以了解（P378）**

# 后端编译与优化
Hotspot中，java程序先由解释器进行解释执行，当发现某个方法或代码块运行很频繁，就会将这类代码认定为热点代码。这类热点代码会用编译器编译成本地机器码并存储在内存中，在这个过程中编译器会进行各种编译优化算法以加快这段代码的执行速度。

### 解释器与编译器
在程序刚开始运行时，通过解释器一条指令一条指令的解释执行，在运行了一段时间之后找到热点代码，然后将热点代码通过编译器编译优化。当内存不足时，也可以只使用解释器，另外，解释器的存在也为编译器激进优化充当后备的“逃生门”角色。

HotSpot虚拟机内置了一个解释器和两个（或三个）即时编译器。存在多个即时编译器的作用在于分层编译，第一层编译器（客户端编译器，C1）编译速度较快，编译后的优化效果较不明显，采用的策略较为保守。第二层编译器（服务端编译器，C2）编译速度较慢，编译后的优化效果较明显，采用的策略较为激进。分层编译的存在是因为编译器编译的时间会占用程序原本的运行时间。

### 编译对象与触发条件
编译目标就是前面提到的“热点代码”，包括两类：被多次调用的方法与被多次执行的循环体。对于这两类，编译目标都是整个方法体。

怎样确定“热点代码”呢？HotSpot虚拟机采用的是基于计数器的热点探测，HotSpot虚拟机为每个方法准备了两个计数器，分别是方法调用计数器和回边计数器，这两个计数器任何一个的计数超过阈值，就认为这是“热点代码”，并触发即时编译。
对于方法调用计数器，方法每调用一次，计数器值就加一，当计数器值超过阈值后就触发即时编译，当一定时间之后还没有达到阈值，就将计数器取值减半，这里的一定时间就称为“半衰周期”。默认情况下，C1的阈值是1500，C2的阈值时10000。
对于回边计数器（回边的意思是，方法执行时，遇到控制流向后跳转的指令，就称为“回边(Back Edge)”，每遇到一次回边，计数器值就加一。同样的，当回边计数器的值超过一定阈值后就触发即时编译。阈值的计算规则在P395。

### 编译过程
前端编译器：注重与较为简单的局部性优化，放弃了耗时较长的全局优化。
后端编译器：会执行大部分的经典优化动作，比如无用代码消除、循环展开、循环表达式外提等，这些和编译原理很相关。

### 提前编译器
由于提前编译器和平台相关，与java的平台无关性相违背，因此很长时间内都没有很好的应用。但是Android 4.4出现的ART就是使用的提前编译，而且效果很好。也因此影响到了java世界中的提前编译器的革命。

即时编译器最大的缺点就是：编译耗时会占用原本用于程序运行的时间。

==这一段没有仔细看，以后有时间再看==

### 编译器优化技术
**方法内联**
将目标方法的代码原封不动地“复制”到发起调用的方法中，这样就能避免发生真实的方法调用。方法内联是其它很多优化算法的基础，因为如果不把方法合到一起，很难进行优化。

**逃逸分析**
分析对象的作用域。当一个对象在方法内被定义，但是它可能被外部方法所引用（例如传参），那么这种称为方法逃逸。更进一步如果能被外部线程访问，则称为线程逃逸。对于不同的逃逸程序，进行不同的优化。
* 栈上分配：如果一个对象**不会发生线程逃逸**，实际上就没必要在堆中创建。完全可以在使用这个对象的线程的栈中进行创建。随着栈帧的出栈就自动完成了销毁，减轻了垃圾回收的压力。（目前的Hotspot虚拟机还不支持对象的栈上分配，只支持标量替换，而且标量替换的用途也很有限，参考[When can Hotspot allocate objects on the stack?](https://stackoverflow.com/questions/43002528/when-can-hotspot-allocate-objects-on-the-stack/43002529#43002529)）
* 标量替换：原始数据类型和引用类型都不能进一步分解成更小的类型，这种数据称为**标量**。相反的就称之为聚合量，Java对象就是典型的**聚合量**。如果能证明一个对象**不会发生方法逃逸**，那么在程序真正执行时，就可以不去创建这个对象，而是选择直接创建这个对象所拥有的成员变量来代替。
* 同步消除：如果能确定一个变量**不会发生线程逃逸**，那么就一定是线程安全的，可以去除对这个变量实施的同步措施。

**公共子表达式消除**
这是编译原理学过的编译器优化技术。如果一个子表达式已经计算过，那么就不会重复计算。

**数组边界检查消除**
JVM会帮我们进行数组越界检查，但是如果每次访问数组都进行一次检查，那么无疑会降低效率。如果数组下标是个常量，那么在编译期通过数据流分析出没有越界，就不用进行检查。更常见的，如果对数组的访问发生在循环之中并且使用循环控制变量来访问数组，如果能确定这个循环控制变量的范围在[0, array.length)之间，那么就这个循环体内，就不用进行数组的上下界检查，可以节省很多次条件判断操作。

更宽泛的：由于java会进行很多的安全检查，如数组越界检查，除零检查，空指针访问检查等等。这些安全检查会拖慢程序的运行速度。除了类似于数组边界检查消除这种在编译器进行优化的选择之外，还有一种思路称为隐式异常处理，这种思路就是不进行异常检查，当真的发生异常的时候，用一种花费时间非常长的手段来恢复中段并抛出相应异常。虽然当异常发生时的处理比判断操作要慢得多，但是如果异常发生概率很低那么还是值得的。