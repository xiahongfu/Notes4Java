[TOC]
## java内存模型
java为了支持并发操作定义了一套模型，称为Java内存模型（JMM）。java内存模型和java内存结构是两个概念。这两者基本没有关系，属于在不同层次上对内存进行的划分。

### 主内存与工作内存
JMM将内存划分成两个部分：主内存和工作内存。主内存是所有线程共享的，JMM规定所有变量都应存储在主内存中。工作内存是每个线程私有的，工作内存中存放的是主内存中变量的副本。当线程想要使用某个变量时，必须将变量从主内存拷贝一份到自己的工作线程中，而不能直接读写主内存中的数据（即使用volatile描述的变量也不例外）。

### 内存间交互操作
线程的并发安全问题来源于线程对共享数据的读写操作不一定能及时传递到其它线程中。也就是说，线程的并发安全问题本质上来源于对某个线程对共享变量的修改不能及时传递到其它线程当中。
Java内存模型定义了8种原子操作
* lock：作用于主内存的变量。将变量标识为一条线程独占的状态。
* unlock：作用于主内存的变量。对lock操作的解锁
* read：作用于主内存的变量。将一个变量从主内存拷贝到某个线程的工作内存中。（这时候还没有放到该变量在工作内存的变量副本中）
* load：作用于工作内存的变量。将read操作得到的变量放入到该变量在工作内存的变量副本中。
* use：作用于工作内存的变量。将工作内存中的一个变量的值传递给执行引擎。（也就是说，线程使用的都是该变量在工作内存的副本，而不是在主内存的变量）
* assign：作用于工作内存的变量。从执行引擎接收一个变量并存储在相应的变量副本中
* store：作用于工作内存的变量。从工作内存将变量副本的值传送到主内存中（还没有放到主内存真正的变量位置当中）
* write：作用于主内存的变量。将store操作得到的变量放入到该变量在主内存的变量中。

这八种基本操作还需要满足一些约束条件，比如store-write、read-load必须成对出现。这些约束条件见P443，不是很重要。

### 对于volatile型变量的特殊规则
volatile可以说是java虚拟机提供的最轻量级的同步机制。

**可见性**
volatile变量保证可见性，即当一条线程修改了这个变量的值，新值对于其它线程立即可知。volatile不保证原子性，因此如果不符合以下两个规则，仍然需要通过加锁来保证原子性。
* 运算结果不依赖变量的当前值。或能确保只有单一线程修改变量的值
* 变量不需要与其它状态变量共同参与不变约束

volatile如何保证可见性？java内存模型对volatile型变量定义了一些特殊的规则
* 线程使用一个volatile变量前，都会从主内存中刷新变量的最新值，用于保证可以看见其它线程对该变量的修改。
* 线程在修改一个volatile变量后，都会立即将修改后的值同步回主内存中，用于保证其它线程可以看到该线程对该变量的修改。

**禁止指令重排序**
jvm虚拟机在执行程序时，不一定按照程序原先的顺序执行，有可能会对指令进行重排序来达到优化的目的。而指令重排序可能会导致并发执行时出现意想不到的问题。内存屏障可以保证在指令重排序后，这条指令与其它所有指令的相对位置不变（在这条指令前的依旧在前，在后的依旧在后）。volatile就是使用内存屏障来实现禁止指令重排序的，保证在这条指令之前执行的依旧在前面执行，在这条指令之后执行的依旧在之后执行。关于内存屏障的更多细节书上也没有，可以参考这篇文章【[一文解决内存屏障](https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/)】

### 针对long和double的特殊规则
long和double的非原子性协定允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位操作来进行。对于32位的java虚拟机，可能会出现读取了半个变量的情况。对于主流的64位java虚拟机来说，对long和double的操作都满足原子性。

### 先行并发规则
* 程序次序规则：一个线程内，按照控制流顺序，写在前面的操作先行发生于写在后面的操作。
* 管程锁定规则：unlock操作先行发生于后面对同一个锁的lock操作
* volatile变量规则：对volatile变量的写操作先行发生于后面对这个变量的读操作
* 线程启动、终止、中断规则：这是显然的，可以看书。
* 对象终结规则：对象的初始化动作先行于这个对象的finalize方法
* 传递性：A先行于B，B先行于C，则A先行于C。

如果A先行并发于B，那么A的结果对B可见。上面的先行并发规则就是总结了有哪些先行并发的情况。程序在满足这些情况的时候，A的结果一定对B可见，因此就不需要进行并发控制。

## 线程安全和锁优化
书上把线程安全分为五类，感觉不重要就没总结

### 线程安全的实现方法
**互斥同步**
* synchronized关键字：java中最基本的互斥同步手段就是synchronized关键字。synchronized关键字在经过javac编译后会在同步块前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码之后都需要一个引用类型数据作为加锁解锁对象。如果synchronized关键字没有指定对象参数，就看情况选择实例对象this或Class对象作为加锁解锁的对象。
* Lock接口：不需要用块结构来实现互斥同步。Lock应该确保在finally中释放锁，否则可能try块中发生异常就导致永远无法释放锁。synchronized是在jvm层面上保证了即使出现异常锁也能自动释放。
* 重入锁（ReentrantLock）：是Lock结构的一个常用实现。与synchronized区别在于等待可中断、可实现公平锁、锁可以绑定多个条件。作者更推荐使用synchronized。

**非阻塞同步**
互斥同步也称为阻塞同步，因为它是通过阻塞的方式保证不会有多个线程同时进入同步块中。由于无论是否会有其它线程竞争，互斥同步每次都需要通过加锁的方式保证同步，因此也称为**悲观锁**，即：如果我不加锁，我就觉得一定会出现问题，因此无论如何我每次都会加锁。
与之对应的是非阻塞同步，即：不管风险，先进性操作，如果没有竞争，那么就操作成功，如果有竞争力，则采取一定的补救措施（通常是重复执行）。非阻塞同步也称为**乐观锁**。这种并发操作不需要将线程阻塞挂起，节省了系统资源。

java中使用CAS(Compare-and-Swap)来实现乐观锁。其CAS是一条CPU指令，是原子操作。这个指令需要三个操作数，分别是内存位置（存放的变量用A表示）、预期的旧值（用B表示）、准备设置的新值（用C表示）。如果A和B相等，则说明这段时间没有被修改该变量没有被修改，这是就将C的值写进去。如果A和B不等，就重新进行计算，并再次进行CAS，知道成功为止。

**无同步**
实际上就是不会引起线程安全的代码，这时候就不需要进行同步。
可重入代码：无论什么时候中断，再次执行时不会出现任何错误。这种代码不涉及全局变量、堆上数据、公用系统资源。用到的所有变量都由参数传入。
线程本地存储：如果一段代码只用到了线程内部的数据，即不会发生线程逃逸，那么也就无需进行线程同步。

### 锁优化

**自旋锁**
如果共享数据的锁定状态只持续很短的时间，那么得不到锁的线程不放弃处理器而是选择“稍等一会”，这种技术就称为“自旋锁”。显然需要在多核处理机上才能实现自旋锁。由于多数情况下，共享数据的锁定状态确实只持续很短的时间，因此自旋锁还是非常有用的。如果自旋了一段时间后仍然无法成功获得锁，则仍然会进入挂起状态。
**自适应自旋**：根据是否成功获得锁的历史情况来动态调整自旋的次数。
synchronized的重量级锁使用了自适应自旋优化。

**锁消除**
如果判断一段代码中，在堆上的所有数据都不会发生线程逃逸，则可以把它们当成栈上数据来看待。此时就无需进行同步加锁操作。

**锁粗化**
将对同一个变量的连续的非常细粒度的加锁解锁操作进行合并，合并成一整个的加锁解锁操作。比如将循环内部的加锁解锁操作，挪到循环外部上来。

**轻量级锁**
就是上面说的非阻塞同步，也就是CAS。具体操作过程可以看书上P481。

**偏向锁**
偏向锁的意思是：这个锁会偏向于第一个获得它的线程，如果一直只有一个线程请求锁，那么持有偏向锁的线程将永远不需要再进行同步。但是来了另一个线程和这个进程竞争，那么偏向模式立马宣告结束。之后的同步操作就按照轻量级锁那样去执行。