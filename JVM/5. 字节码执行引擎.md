JVM以方法作为最基本的执行单元。而方法的执行依赖于“栈帧”这个数据结构。每个线程都有一个栈帧，处于栈顶的栈帧对应的方法就是当前线程正在执行的方法。栈帧中存储了一个方法从开始调用到执行结束锁需要的所有信息。一个方法从开始调用到执行结束，对应了一个栈帧的入栈和出栈。因此，栈帧和方法的执行是息息相关的。
**栈帧中存放的信息**：局部变量表、操作数栈、动态连接、方法返回地址、以及一些额外的附加信息。在程序的编译阶段，需要多大的局部变量表以及多深的操作数栈，都已经确定下来了，放在方法表的Code属性当中。也就是说，一个栈帧需要多少内存，在程序的编译阶段就已经确定下来了。
接下来逐一讲解栈帧中存放的各个数据

### 局部变量表
局部变量表的基本单位是变量槽（根据实现不同，变量槽的大小可以设计成32位和64位）。在变量槽大小为32位时，会为64位数据分配连续的两个变量槽（任何情况下，都不能单独访问其中一个变量槽）。对这连续两个变量槽的读取不是原子操作，由于栈帧是线程私有，因此不会引起线程安全问题。
JVM通过索引定位方式使用局部变量表，索引N代表使用第N个变量槽（如果是64位变量，代表使用第N和第N+1个变量槽）。对于实例方法，第0位索引用于存放this。

变量槽可以重用，当PC的值已经超出了某个变量的作用域时，那么这个变量所占用的变量槽可以交给其它变量重用。

另外，局部变量不想类变量一样存在准备阶段。因此所有的局部变量在使用时都要保证已经赋过初值。

### 操作数栈
JVM执行字节码指令时，有些指令会将操作数存入操作数栈中，有些指令会从操作数栈中取操作数进行运算。在编译阶段以及类校验阶段的数据流分析中都会严格保证“操作数栈中的元素与字节码指令的序列严格匹配”。比如说，iadd命令是两个int型数据相加，那么此时栈顶一定有两个int型数据。
另外操作数栈也可以在不同的栈帧间出现一部分的重叠，这样就无需进行额外的参数复制传递了。

### 动态连接
<mark>8.3和8.4还没看，之后再看</mark>

### 方法返回地址
只有两种方法导致方法运行结束。
第一种：正常结束，根据方法的返回指令来确定方法的返回值与返回地址。
第二种：程序出现异常，且在本方法的异常表中没有匹配到异常处理器，就会导致方法退出，这时候不会有返回值。

### 附加信息
完全取决于虚拟机的具体实现
