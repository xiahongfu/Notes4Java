# CPU 缓存一致性
## 总线嗅探
如果某个CPU核心更新了Cache中的数据，且这个数据是共享变量的时候（Java中的volatile），那么要把该事件广播到其它核心。最常见的实现方法是**总线嗅探**（Bus Snooping）。每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态。

**MESI协议**：是基于总线嗅探机制实现的一个协议，用于实现事务串行化，同时降低总线带宽压力。

**伪共享问题**：如果多个变量存放在一个cache块中，那么无论哪一个变量改变了，那么都需要将缓存标记为失效。

# 异常
**异常控制流**
现代操作系统通过是控制流发生突变来对系统的状态变化作出反应。把这些突变称为异常控制流（Exceptional Control Flow, ECF）。ECF发生在计算机系统的各个层次。

异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。

当处理器**状态**发生一个重要变化时（这里的状态变化称之为**事件**），处理器会停下当前的程序，转而执行异常处理程序，当异常处理完成后，会根据异常类型的不同，执行以下三种操作之一：
* 执行异常发生时的指令
* 执行异常发生时的下一条指令
* 终止被中断的程序

**异常的处理**
系统中的每种异常都有一个**异常号**，其中一些是处理器的设计者分配的（除零、缺页、内存访问违规、算数运算溢出等），还有一些是操作系统内核设计者分配的（系统调用、来自I/O设备的信号）。

在系统启动时，操作系统会初始化一张异常表，每一种异常号都会对应一个异常处理程序的地址。

在程序执行时，处理器检测到发生了一个事件，并且确定了异常号k，随后处理器触发异常，通过异常号k得到异常处理程序入口地址。然后开始异常处理程序

**异常的类别**
异常可以分为四类，分别是中断（interrupt）、陷阱（trap）、故障（fault）、终止（abort）。

|类别	   |  原因 | 异步/同步 | 返回行为|
|---|---|---|---|
|中断	   | 来自I/O设备的信号 | 异步 | 总是返回到下一条指令 |
|陷阱	   | 有意的异常 | 同步 | 总是返回到下一条指令 |
|故障	   | 潜在可恢复的错误 | 同步 | 可能返回到当前指令 |
|中止	   | 不可恢复的错误 | 同步 | 不会返回 |

**中断**
中断是异步的，来自**处理器外部的I/O设备**（如鼠标、键盘、内存、网络）的信号的结果。处理器注意到中断引脚的电压变高了就会从系统总线读取异常号，然后调用相应的中断处理程序。

**陷阱**
陷阱是有意的异常，主要作用是实现**系统调用**，每个系统调用都相当于是一种陷阱，应用程序调用系统调用，操作系统找到当前系统调用的处理程序运行，运行完成后执行下一条指令。

**故障**
故障由错误情况引起，但是能够被故障处理程序修正。故障发生时，处理器将控制转移给故障处理程序。一个经典的故障就是缺页异常。

**终止**
终止是不可恢复的致命错误。发生了终止异常之后，操作系统就会终止这个应用程序。


# 虚拟内存
虚拟内存旨在在逻辑上扩充内存容量。

应用程序在运行之前没必要将所有内容全部装入内存，只需要将一部分数据装入内存即可。在程序运行时，如果要访问的页已经在内存中了，那么就可以继续执行下去，如果要访问的页不在内存中，那么就发出缺页中断请求，此时操作系统会将缺失的页面重新装入内存。如果此时内存已满，就采用页的置换功能，将暂时不用的页置换到磁盘上。

**页面置换算法**
* 最佳置换算法：只在理论上存在，用于评判其它置换算法的性能。
* FIFO页面置换算法：最先进入的最先淘汰。
* LRU最近最久未使用：将最久没用的那个给置换掉
* LFU最近最不经常使用：将最近最不经常使用的那个页置换掉











