[TOC]
# 什么是缓存
缓存就是将数据库中的部分数据放到redis中存储。这样如果请求的是这些在缓存中存在的数据，就可以直接从缓存中返回给用户，而不需要访问数据库，从而减轻了数据库的压力。

由于访问数据库操作相对较慢，访问缓存速度相对较快，因此将部分热点数据放在缓存中存储也可以提高读写效率，降低响应时间。

缓存可能带来数据不一致问题，增大代码的维护成本以及运维成本。

# 缓存更新策略
缓存与数据库可能存在不一致的问题，如何解决这种缓存不一致问题，主要有超时剔除与主动更新两种方式。
### 超时剔除
给缓存数据添加TTL时间，到期后由redis自动删除缓存。然后在缓存未命中时再从数据库写回到缓存中即可。这种方式的数据一致性较低，维护成本也低。

### 主动更新缓存
编写业务逻辑，在修改数据库的同时更新缓存。在实践中有以下几种主动更新缓存的策略。

##### 1. Cache Aside Pattern
读取：应用程序先从cache中取数据，如果取到了则直接返回。没有取到则从数据库中取数据，然后放回到缓存中。
更新：**先更新数据库，再让缓存失效。**

注意更新时是先更新数据库，再让缓存失效。如果先让缓存失效，再更新数据库的话，假设缓存失效后还没更新数据库，此时有其它线程读数据后访问了数据库，这时就会将旧数据再读回缓存。
先更数据库再让缓存失效也可能产生脏数据，比如如果缓存一开始就是失效的，这时第一个线程从数据库中读到脏数据后还没来得及写回缓存，此时第二个线程更新数据库然后让缓存失效，然后第一个线程将脏数据又写回缓存，这就产生了脏数据。但是这种情况发生的概率较低，

为什么是删除，而不是修改？
##### 2. Read/Write Through Pattern
将缓存和数据库合并为一个服务，对调用者来说是透明的。调用者无需关心缓存的一致性问题。

##### 3. Write Behind Caching Pattern
调用者只操作缓存，更新时只对缓存进行更新，所有的数据都在缓存中。然后由另一个线程异步地将数据从缓存持久化到数据库中，保证数据最终一致。这种方案较为复杂，且当缓存服务器异常宕机崩溃后可能会丢失部分数据。

# 缓存穿透
缓存穿透指的是客户端请求的数据在缓存中和数据库中都不存在，这样缓存就永远不会生效，这些请求都会打到数据库中。有以下两种解决办法：

### 缓存空对象
当请求的数据不存在于数据库中时，在缓存中记录一个缺省值，当后续再次请求这个数据时返回这个缺省值。

### 布隆过滤器 
布隆过滤器：不同的数据会对应不同的二进制位。每次存入一个数据时，就将这条数据对应的二进制位全部置为1。判断某条数据是否存在时，就根据对应的二进制位进行判断，如果对应的二进制位全为1，则代表啊可能存在，否则代表一定不存在。布隆过滤器的原理就是哈希表。

在缓存的前面再增加一层布隆过滤器，当过滤器认为某条数据一定不存在时就直接返回空。

# 缓存雪崩
缓存雪崩是指在同一时间段内大量的缓存key同时失效，或者redis服务宕机，导致大量请求直接打到数据库，造成数据库的大量压力。 

解决方案：
* 给不同的key的TTL添加随机值，防止这些key同时到期。
* 利用redis集群提高服务的可用性
* 给缓存业务添加降级限流策略
* 给业务增加多级缓存

# 缓存击穿
缓存击穿问题也叫热点key问题。就是一个**被高并发访问**且**缓存重建较为复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

解决方案：
* 设置热点数据永不过期
* 加互斥锁：只允许一个线程进行缓存重建。
* 逻辑过期：给key设置逻辑过期时间。当请求发现缓存过期后，1）请求互斥锁，2）开启一个新的线程进行缓存重建，3）释放锁。当前请求仍然返回旧的缓存数据。